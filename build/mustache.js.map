{"version":3,"file":"mustache.js","mappings":"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","sources":["webpack://mustache/webpack/universalModuleDefinition","webpack://mustache/webpack/bootstrap","webpack://mustache/webpack/runtime/define property getters","webpack://mustache/webpack/runtime/hasOwnProperty shorthand","webpack://mustache/webpack/runtime/make namespace object","webpack://mustache/./src/utils.ts","webpack://mustache/./src/Scanner.ts","webpack://mustache/./src/Context.ts","webpack://mustache/./src/parseTemplate.ts","webpack://mustache/./src/Writer.ts","webpack://mustache/./src/mustache.ts","webpack://mustache/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mustache\"] = factory();\n\telse\n\t\troot[\"mustache\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @description 以下都是为正文准备的工具方法，可以先浏览一遍对所有方法有一个印象\n */\nconst objectToString = Object.prototype.toString\nexport const isArray = Array.isArray || function isArrayPolyfill(object: any): boolean {\n  return objectToString.call(object) === '[object Array]'\n}\n\nexport function isFunction(object: any): boolean {\n  return typeof object === 'function'\n}\n\n/**\n * 检查 obj 是否为对象且 propName 是否为 obj 的属性（继承或原型链上的属性也符合）\n * @param {any} obj \n * @param {symbol | string | number} propName \n * @returns {boolean}\n */\nexport function hasProperty(obj: any, propName: symbol | string | number): boolean {\n  return obj != null && typeof obj === 'object' && (propName in obj)\n}\n\n/**\n * 判断 primitive 是否不为 null 且不为 object 且有 hasProperty 并且 propName 是 primitive 的属性\n * \n * 例如 string 类型将符合要求\n * \n * @param {any} primitive \n * @param {string} propName \n * @returns {boolean}\n */\nexport function primitiveHasOwnProperty(primitive: any, propName: string): boolean {\n  return (\n    primitive != null\n    && typeof primitive !== 'object'\n    && primitive.hasProperty\n    && primitive.hasProperty(propName)\n  )\n}\n","/**\n * 扫描器，传入字符串模板 string，通过标记 tag 收集相关 string 片段。\n * \n * scanUntil 可以收集 tag 前的字符\n * scanner 可以标识当前 tag 是否位于 string 开头\n * eos 判断 string 是否已扫描完成\n * \n * 例子：\n *  入参字符串模板为 '你好，{{name}}！'\n * \n *  scanner.scanUntil('{{') -> '你好，'\n *  scanner.eos()           -> false\n *  scanner.scan('{{')      -> '{{'\n *  scanner.eos()           -> false\n *  scanner.scanUntil('}}') -> 'name'\n *  scanner.eos()           -> false\n *  scanner.scan('}}')      -> '}}'\n *  scanner.eos()           -> false\n *  scanner.scanUntil('{{') -> '！'\n *  scanner.eos()           -> true\n */\nexport default class Scanner {\n  private string: string // 入参字符串模板\n  private tail: string // 每次扫描剩下的字符串，扫描器会从前往后扫描\n  public pos: number // 对于入参字符串模板的当前扫描到的位置\n  constructor(string: string) {\n    this.string = string\n    this.tail = string\n    this.pos = 0\n  }\n  /**\n   * 判断字符串是否已扫描完成\n   * @returns {boolean}\n   */\n  public eos(): boolean {\n    return this.tail === ''\n  }\n  /**\n   * 扫描 tag，如果 tag 在 tail 开头位置那么把 tag 匹配的字符截取并返回，否则返回空字符。\n   * \n   * @param {RegExp | string} re tag 的正则表达式或字符串\n   * @returns {string}\n   */\n  public scan(re: RegExp | string): string {\n    const match = this.tail.match(re)\n\n    if (!match || match.index !== 0) { // 如果没有匹配到或匹配到的 tag 字符串不在 tail 开头，那么返回空字符\n      return ''\n    }\n\n    const string = match[0]\n\n    this.tail = this.tail.substring(string.length)\n    this.pos += string.length\n\n    return string\n  }\n  /**\n   * 扫描 tag，跳过匹配字符串之前的字符串，并返回跳过的字符串。\n   * \n   * 三种情况：\n   *  1、如果没有匹配字符串，则返回整个 tail。\n   *  2、如果匹配字符串在 tail 的头部，说明没有可跳过的字符串，返回空字符。\n   *  3、如果匹配字符串在 tail 的中间，那么返回匹配字符串之前的字符串。\n   * \n   * 例子：\n   *  假设 tag 是 {{，\n   *    对于第一种情况，有 'hello' -> 'hello'\n   *    对于第二种情况，有 '{{hello}}' -> ''\n   *    对于第三种情况，有 'hello，{{hi}}' -> 'hello，'\n   * \n   * @param {RegExp | string} re tag 的正则表达式或字符串\n   * @returns {string}\n   */\n  public scanUntil(re: RegExp | string): string {\n    const index = this.tail.search(re)\n    let match: string\n\n    switch (index) {\n      case -1: // 第一种情况\n        match = this.tail\n        this.tail = ''\n        break\n      case 0: // 第二种情况\n        match = ''\n        break\n      default: // 第三种情况\n        match = this.tail.substring(0, index)\n        this.tail = this.tail.substring(index)\n    }\n\n    this.pos += match.length // 同时扫描指针要后移\n\n    return match\n  }\n}\n","import { isFunction, hasProperty, primitiveHasOwnProperty } from './utils'\n\n/**\n * 存储值，可以根据对应规则的标识取出特定值。\n * \n * 比如：初始化时存储的 view 是 'Tom'，那么可以调用 context.lookup('.') 取出 'Tom'，具体规则请看 lookup 方法\n */\nexport default class Context {\n  public view: any\n  public cache: { '.': Context['view'], [key: string]: any }\n  public parent?: Context\n  /**\n   * \n   * @param {any} view // 渲染值，比如 view = { name: 'Tom' }，那么调用 lookup('name') 会返回 'Tom'\n   * @param {Context} parentContext \n   */\n  constructor(view: any, parentContext?: Context) {\n    this.view = view\n    /**\n     *  缓存每次拿到的结果, 初始值为 '.'，应用场景是 {{.}}，\n     * 在每次 lookup(name) 时都会把得出的结果添加到 cache 中，下一次直接获取缓存值。比如：\n     * \n     * this.view = { a: { b: { c: 'Tom' } } }\n     * this.lookup('a') // cache: { '.': { a: { b: { c: 'Tom' } } }, 'a': { b: { c: 'Tom' } } }\n     * this.lookup('a.b') // cache: { '.': { a: { b: { c: 'Tom' } } }, 'a': { b: { c: 'Tom' } }, 'a.b': { c: 'Tom' } }\n     * this.lookup('a.b.c') // cache: { '.': { a: { b: { c: 'Tom' } } }, 'a': { b: { c: 'Tom' } }, 'a.b': { c: 'Tom' }, 'a.b.c': 'Tom' }\n     */\n    this.cache = { '.': this.view }\n    this.parent = parentContext\n  }\n\n  /**\n   * 创建一个 Context 实例，并把自身作为该实例的父 Context\n   * \n   * @param {any} view 渲染值\n   * @returns {Context}\n   */\n  public push(view: any): Context {\n    return new Context(view, this)\n  }\n\n  /**\n   * 给定 name，查找 Context 实例是否有对应的值。\n   *  \n   * 查找规则：通过存储的 view 或 context 查找。\n   * \n   * 比如 view = { a: { b: c: 'Tom' } }, name = 'a.b.c' ，那么可以找到结果，结果为 'Tom'。\n   * 比如 view = { a: 'Tom' }, name = 'b' ，那么 view 中找不到对应结果，如果有父 context，将会找父 context 中的 view，直到找到或不再存在父 context 为止。\n   * \n   * @param {string} name 属性链，比如是 '.'、'a'、'a.b.c' 等\n   * @returns {any}\n   */\n  public lookup(name: string): any {\n    const cache = this.cache // 获取缓存结果对象\n\n    let value: any // 结果值\n    if (cache.hasOwnProperty(name)) { // 如果在之前缓存有该值，那么直接取到\n      value = cache[name]\n    } else {\n      let context: this | Context['parent'] = this // 当前作用域\n      let intermediateValue: any // 过渡值，类似于数组两个数交换时定义的一个 temp\n      let names: string[] // 分割后的 name 数组\n      let index: number // 指向 names 的索引\n      let lookupHit = false // 是否找到目标值\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          intermediateValue = context.view // 初始化 intermediateValue\n          names = name.split('.') // 如果 name 是 'a.b.c'，则拆成 ['a', 'b', 'c']\n          index = 0\n\n          while (intermediateValue != null && index < names.length) {\n            if (index === names.length - 1) {\n              lookupHit = (\n                hasProperty(intermediateValue, names[index])\n                /**\n                 * 这种情形在 intermediateValue 是个字符串，names[index] 是索引时适用\n                 * \n                 * intermediateValue = 'hello'\n                 * name = a.b.c.0, names[index] = '0'\n                 * \n                 * primitiveHasOwnProperty(intermediateValue, names[index]) // true\n                 */\n                || primitiveHasOwnProperty(intermediateValue, names[index])\n              )\n            }\n\n            /**\n             * 这个操作相当于链式获取某个值，比如：\n             * \n             *  intermediateValue = { a: { b: { c: 'Tom' } } }, names = ['a', 'b', 'c']\n             * \n             * 那么每次循环的情景是：\n             *  intermediateValue = intermediateValue['a'] // { b: { c: 'Tom' } }\n             *  intermediateValue = intermediateValue['b'] // { c: 'Tom' }\n             *  intermediateValue = intermediateValue['c'] // 'Tom'\n             */\n            intermediateValue = intermediateValue[names[index++]]\n          }\n        } else { // 如果 name 中没有 .\n          intermediateValue = context.view[name]\n\n          lookupHit = hasProperty(context.view, name)\n        }\n\n        if (lookupHit) { // 如果找到了目标值，那么结束循环\n          value = intermediateValue\n          break\n        }\n\n        context = context.parent // 如果没有找到目标值，那么继续往上找父 context，直到找到或 context 为空\n      }\n\n      cache[name] = value // 向 cache 添加结果，下次遇到相同值直接取出\n    }\n\n    if (isFunction(value)) { // 如果 value 是一个函数，那么调用该函数把返回值赋值给 value\n      value = value.call(this.view)\n    }\n\n    return value\n  }\n}\n","import { mustache, tags, token } from './mustache'\nimport { isArray } from './utils'\nimport Scanner from './Scanner'\n\n/**\n * 在所有 - [ ] { } ( ) * + ? . , \\ ^ $ # 所有空格 前添加 \\\n * 如 '-[]' -> '\\-\\[\\]'\n * @param {string} string \n * @returns {string}\n */\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&')\n}\n\nconst regExpTest = RegExp.prototype.test\nfunction testRegExp(re: RegExp, string: string): boolean {\n  return regExpTest.call(re, string)\n}\n\nconst nonSpaceRe = /\\S/ // 匹配非空字符\nfunction isWhitespace(string: string): boolean { // 检查一个值是否为空白字符串\n  return !testRegExp(nonSpaceRe, string)\n}\n\nconst whiteRe = /\\s*/ // 匹配空白\nconst spaceRe = /\\s+/ // 匹配至少一个空格\nconst equalsRe = /\\s*=/ // 匹配 =\nconst curlyRe = /\\s*\\}/ // 匹配 }\nconst tagRe = /#|\\^|\\/|>|\\{|&|=|!/ // 匹配 #、^、/、>、{、&、=、!\n\n/**\n * 扫描 template，根据 tags 及其规则生成 tokens\n * \n *  tokens 是一个多维数组，其作为某段 template 片段的描述，类似于 AST 抽象语法树，\n * 将文字解析成 tokens 后可以根据里面 token 更好更有规律地转义 template。\n * \n * 例子：\n *  const template = '你好，{{name}}！'\n *  const tags = ['{{', '}}']\n * \n *  parseTemplate(template, tags) // [[ 'text', '你好，', 0, 3 ], [ 'name', 'name', 3, 11 ], [ 'text', '！', 11, 12 ]]\n * \n *  上述 tokens 中的 token 是最基础的形态，类型为 [type, text, startIdx, endIdx]\n * \n *  其中：\n *    type 为该 token 的处理类型，后续可以根据 type 来对该 token 进行处理;\n *    text 为该 token 的文本信息，该文本就是在 template 提取的文本;\n *    startIdx 和 endIdx 为该 token 对于 template 的起始和结束的位置索引;\n * \n *    实际上根据 type 的不同生成的 token 类型也会有所不同，比如某类 token 还会存储儿子 token，\n *  这就是说为什么 tokens 是一个多维数组的原因。具体的 token 生成规则和处理方法，请继续往下看。\n * \n * 注：下面所有例子和描述的 tags 以默认值 ['{{', '}}'] 为例\n * \n * @param {string} template 字符串模版\n * @param {tags} tags 标记\n * @returns {token[]} tokens\n */\nexport default function parseTemplate(template: string, tags?: tags): token[] {\n  if (!template) {\n    return []\n  }\n  let lineHasNonSpace = false // 当前行是否有非空格\n  const sections = [] // 存储 {{#names}}、{{^names}} 标记，用于判断这些标记是否有匹配 {{/names}}\n  const tokens: token[] = [] // token 数组\n  let spaces: number[] = [] // 存储在当前行中每个空格的 token 索引，当遇到 {{#names}} 时且当前项全是空格时，会把 tokens 中对应 spaces 索引的 token 全部删除\n  let hasTag = false // 当前行是否有标签 {{}}\n  let nonSpace = false // 是否有非空格\n  let indentation = '' // 当前行收集到的缩进，又称空白字符串\n  let tagIndex = 0 // 每一行文本所遇到的 {{}} 数量\n\n  /**\n   * 当遇到 {{#names}} 且当前行全部为空格时，会把所有空格移除。\n   * \n   * 例如 : \n   *  template: '    {{#names}}    \\n{{name}}{{/names}}'\n   *  view: { names: { name: 'Tom' } }\n   * \n   *  output: 'Tom'\n   * \n   * {{#names}} 前后的空格已被移除，但当 {{#names}} 所在的当前行如果有非空格字符，这个规则将不适用。\n   */\n  function stripSpace(): void {\n    if (hasTag && !nonSpace) { // 如果检测到有标签且全是空格，这里的标签只能是 {{#names}}\n      while (spaces.length) // 删除 tokens 中所有空格 token\n        delete tokens[spaces.pop() as number]\n    } else {\n      spaces = [] // 重置\n    }\n\n    hasTag = false // 重置\n    nonSpace = false // 重置\n  }\n\n  let openingTagRe: RegExp // 开口标签正则\n  let closingTagRe: RegExp // 闭口标签正则\n  let closingCurlyRe: RegExp // } + closingTagRe 正则，比如闭口标签为 }}，那么该正则为 }}}\n  /**\n   * 处理 tags，根据 tags 生成对应的正则表达式，tags 必须为数组或字符串，例如 ['{{', '}}'] 或 '{{ }}'\n   * \n   * 为什么会有字符串？因为在遇到 {{=<% %>=}} 的时候会把 '<% %>' 作为参数传入，这时就需要将其解析为标签\n   * \n   * @param {string | tags} tagsToCompile \n   */\n  function compileTags(tagsToCompile: string | tags): void {\n    if (typeof tagsToCompile === 'string') {\n      tagsToCompile = tagsToCompile.split(spaceRe, 2) as tags // 生成至少一个空格作为分隔符，长度为 2 的数组，例如： '{{  }}' -> ['{{', '}}']\n    }\n\n    if (!isArray(tagsToCompile) && (tagsToCompile as string[]).length !== 2) { // 如果 tagsToCompile 不是数组或数组长度不等于 2，说明不符合条件，抛出错误\n      throw new Error('Invalid tags: ' + tagsToCompile)\n    }\n\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*') // /\\{\\{\\s*/\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1])) // /\\s*\\}\\}/\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1])) // /\\s*\\}\\}\\}/\n  }\n\n  compileTags(tags || mustache.tags) // 初始化编译一个 tags 确定标签的样式\n\n  const scanner = new Scanner(template) // 创建扫描器，下面循环将围绕扫描器收集 token\n\n  let start: number // 每次扫描一对 {{}} 即每次循环时，扫描器 scanner 的当前指针\n  let type: string // 每个标签的类型，后面会根据类型去处理 token\n  let value: string // {{ 或 }} 前的文本，比如：'hello, {{name}}' 对应的文本是 hello, 和 name\n  let chr: string // 文本中每一个字符\n  let token: token // 存储的信息标识\n  let openSection: token | undefined // 每次遇到 {{/names}} 时从 sections 弹出的开口标签\n  while (!scanner.eos()) { // 循环使扫描器扫描完成，每次循环都会扫描出一对 {{}}\n    start = scanner.pos\n\n    value = scanner.scanUntil(openingTagRe!) // 获取 {{ 前或全部文本\n\n    if (value) { // 循环将文本转换成单字符 token，方便后续处理\n      for (let i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i) // 获取当前字符\n\n        if (isWhitespace(chr)) { // 如果该字符为空白字符，记录该空白 token 的位置，同时增加缩进的长度\n          spaces.push(tokens.length)\n          indentation += chr\n        } else {\n          /**\n           * @see {Writer.indentPartial} 如果有非空白字符，记录当前行有非空格字符，缩进长度也需增加\n           */\n          nonSpace = true\n          lineHasNonSpace = true\n          indentation += ' '\n        }\n\n        tokens.push(['text', chr, start, start + 1])\n        start += 1\n\n        if (chr === '\\n') { // 如果 chr 是一个换行符，说明当前行已经遍历结束，重置新的行\n          stripSpace()\n          indentation = ''\n          tagIndex = 0\n          lineHasNonSpace = false\n        }\n      }\n    }\n\n    if (!scanner.scan(openingTagRe!)) { // 如果找不到 {{ ，返回\n      break\n    }\n\n    hasTag = true // 否则该行一定有 {{ 标签\n\n    type = scanner.scan(tagRe) || 'name' // 获取标签的类型，要么是特殊标签，要么是普通标签 {{name}}\n    scanner.scan(whiteRe) // 跳过空格\n\n    // 根据 type 收集 value\n    if (type === '=') { // type 为 =，说明需要转换标签样式，收集即将需要转换的样式\n      /**\n       * @see {compileTags}\n       */\n      value = scanner.scanUntil(equalsRe)\n      scanner.scan(equalsRe)\n      scanner.scanUntil(closingTagRe!)\n    } else if (type === '{') { // type 为 { 说明是 {{{name}}}，使得 name 中的值跳过转义，如 name = '<Tom'，那么直接输出 '<Tom'，而 {{name}} 会输出 '&lt;Tom'\n      value = scanner.scanUntil(closingCurlyRe!) // 获取 {{{name}}} 中的 name\n      scanner.scan(curlyRe) // 跳过 }\n      scanner.scanUntil(closingTagRe!) // 跳过 }}\n      type = '&' // 无论是 {{&name}} 或 {{{name}}}，其类型都是 &\n    } else {\n      value = scanner.scanUntil(closingTagRe!) // 收集 {{name}} 中的 name\n    }\n\n    if (!scanner.scan(closingTagRe!)) { // 如果没有找到 }}，那么说明标签不匹配，抛出错误\n      throw new Error('Unclosed tag at ' + scanner.pos)\n    }\n\n    if (type === '>') {\n      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace]\n    } else {\n      token = [type, value, start, scanner.pos]\n    }\n    tagIndex++ // 当前行遇到的标签数加一\n\n    tokens.push(token)\n\n    if (type === '#' || type === '^') { // 如果遇到 {{#names}} 或 {{^names}}，\n      sections.push(token) // 把 token 推入 sections 数组。\n    } else if (type === '/') { // 如果遇到 {{/names}}，\n      openSection = sections.pop() // 把与之匹配的 {{#names}} 弹出。\n\n      if (!openSection) { // 如果没有 {{#names}}，说明闭口标签没有匹配的开口标签，抛出错误\n        throw new Error('Unopened section \"' + value + '\" at ' + start)\n      }\n\n      if (openSection[1] !== value) { // 如果两者变量不匹配，例如：{{#names}}{{/ages}}，说明不符合规则，抛出错误\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start)\n      }\n    } else if (type === 'name' || type === '{' || type === '&') { // 这种情况为普通标签\n      nonSpace = true\n    } else if (type === '=') { // 如果 type 为 = ，说明标签需要转换，例如 {{=<% %>=}} 使 {{}} 转为 <%%>\n      compileTags(value)\n    }\n  }\n\n  stripSpace()\n\n  openSection = sections.pop()\n\n  if (openSection) { // 扫描完成，所有的 {{#names}} 都应该被出栈，如果有剩余的 {{#names}} 则说明剩余的开闭标签没有成对出现\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos)\n  }\n\n  // return tokens // 未处理的 tokens\n  // return squashTokens(tokens) // 把连续的 tokens 合并\n  return nestTokens(squashTokens(tokens)) // 把散列的儿子 tokens 合并到父 token 中\n}\n\n/**\n * 把连续序号的散列 token 合并到一个 token 中。\n * \n * 例子：\n *  const tokens = [['text', 'T', 0, 1], ['text', 'o', 1, 2], ['text', 'm', 2, 3]]\n * \n *  squashTokens(tokens) // [['text', 'Tom', 0, 3]]\n * \n * @param {token[]} tokens \n * @returns {token[]}\n */\nfunction squashTokens(tokens: token[]): token[] {\n  const squashedTokens: token[] = [] // 合并完成后的 tokens\n\n  let token: token | undefined\n  let lastToken: token | undefined // 合并的 token\n  for (let i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i]\n\n    if (token) { // token 并非一定存在，在清除空格 token 的情况下当前位置将会是 empty\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') { // 如果当前 token 和合并 token 都是普通文本，那么进行合并操作\n        // 一个普通的 token: ['text', word, startIdx, endIdx]\n        lastToken[1] += token[1]\n        lastToken[3] = token[3]\n      } else {\n        squashedTokens.push(token)\n        lastToken = token\n      }\n    }\n  }\n\n  return squashedTokens\n}\n\n/**\n * 对于类型为 #、^ 的 token 都会有对应的儿子 token，该函数的作用就是把散列的儿子 token 收集起来存储到其父亲 token 中。\n * \n * 例子：\n *  const tokens = [['#', 'a', 0, 6], ['name', 'b', 6, 11], ['/', 'a', 11, 17]]\n * \n *  nestTokens(tokens) // [['#', 'a', 0, 6, ['name', 'b', 6, 11], 11]]\n * \n * @param {token[]} tokens \n * @returns {token[]}\n */\nfunction nestTokens(tokens: token[]): token[] {\n  const nestedTokens: token[] = [] // 结果 tokens\n  let collector = nestedTokens // 当前操作的 token\n  const sections: token[] = [] // 存储操作的 token 的栈，栈顶元素指向当前操作的 token 的父亲 token 或 nestedTokens\n\n  let token: token\n  let section: token\n  for (let i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i]\n\n    switch (token[0]) { // type\n      /**\n       * 如果是开口标签标记，那么他应该有儿子 token，需要对该 token 进行处理\n       * [type, key, startIdx, childrenStartIdx, children, endIdx]\n       */\n      case '#':\n      case '^':\n        collector.push(token)\n        sections.push(token)\n        collector = token[4] = [] // 为当前 token 开辟存储儿子 token 的空间，同时 collector 指向儿子 token\n        break\n      case '/': // 如果遇到结束标签标记，说明当前 collector 已处理完毕\n        section = sections.pop()!\n        section[5] = token[2]\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens\n        break\n      default:\n        collector.push(token)\n    }\n  }\n\n  return nestedTokens\n}\n","import { mustache, token, renderConfig, renderPartials, tags } from './mustache'\nimport parseTemplate from './parseTemplate'\nimport Context from './Context'\nimport { isArray, isFunction } from './utils'\n\n/**\n * Writer 整合了各类工具，集成了 mustache 的各类方法，可以针对 token 的类型处理模板，为核心类。\n * Writer 还具有缓存功能，能够将相同条件下生成的 tokens 进行缓存，在下次遇到相同条件时取出缓存值即可。\n */\nexport default class Writer {\n  public templateCache: {\n    _cache: { [key: string]: token[] },\n    set: (key: string, value: token[]) => void,\n    get: (key: string) => token[] | undefined,\n    clear: () => void,\n  }\n  constructor() {\n    // 创建缓存器，用于缓存转义后的模板 tokens\n    this.templateCache = {\n      _cache: {},\n      set: function set(key, value) {\n        this._cache[key] = value\n      },\n      get: function get(key) {\n        return this._cache[key]\n      },\n      clear: function clear() {\n        this._cache = {}\n      }\n    }\n  }\n\n  /**\n   * 清除缓存对象中的缓存值\n   */\n  public clearCache(): void {\n    if (typeof this.templateCache !== 'undefined') {\n      this.templateCache.clear()\n    }\n  }\n\n  /**\n   * 查找缓存或调用 parseTemplate 方法将 template 转为 tokens\n   * @see parseTemplate\n   * @param {string} template \n   * @param {tags} tags \n   * @returns {token[]}\n   */\n  public parse(template: string, tags?: tags): token[] {\n    const cache = this.templateCache // 获取缓存对象\n    const cacheKey = template + ':' + (tags || mustache.tags).join(':') // 创建缓存标识\n    const isCacheEnabled = typeof cache !== 'undefined' // 获取是否需要缓存标识\n    let tokens = isCacheEnabled ? cache.get(cacheKey) : undefined\n\n    if (tokens == undefined) { // 如果没有缓存或未开启获取，则调用 parseTemplate 得到 tokens\n      tokens = parseTemplate(template, tags)\n      isCacheEnabled && cache.set(cacheKey, tokens)\n    }\n    return tokens\n  }\n\n  /**\n   * 把 tokens 转换为结果视图\n   * @param {string} template 模板\n   * @param {any} view 渲染视图\n   * @param {renderPartials} partials 子模板对象或方法\n   * @param {renderConfig} config 配置项\n   * @returns {string}\n   */\n  public render(template: string, view: any, partials: renderPartials, config: renderConfig | undefined): string {\n    const tags = this.getConfigTags(config)\n    const tokens = this.parse(template, tags)\n    const context = (view instanceof Context) ? view : new Context(view, undefined)\n    return this.renderTokens(tokens, context, partials, template, config)\n  }\n\n  /**\n   * 根据 token 的标识用不同的方法处理 token\n   * @param {token[]} tokens \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {string} originalTemplate template\n   * @param {renderConfig | undefined} config \n   * @returns {string}\n   */\n  private renderTokens(tokens: token[], context: Context, partials: renderPartials, originalTemplate: string, config?: renderConfig): string {\n    let buffer = '' // 结果，由 token 和 context 根据规则生成的文本内容\n\n    let token: token\n    let symbol: string\n    let value: string | undefined\n    for (let i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined // 重置 value\n      token = tokens[i] // 获取当前 token\n      symbol = token[0] // 获取 token 标识\n\n      switch (symbol) { // 根据标识决定使用何种方式处理 token\n        case '#': // {{#name}}\n          value = this.renderSection(token, context, partials, originalTemplate, config)\n          break\n        case '^': // {{^name}}\n          value = this.renderInverted(token, context, partials, originalTemplate, config)\n          break\n        case '>': // {{>name}}\n          value = this.renderPartial(token, context, partials, config)\n          break\n        case '&': // {{&name}} 或 {{{name}}}\n          value = this.unescapedValue(token, context)\n          break\n        case 'name': // {{name}}\n          value = this.escapedValue(token, context, config)\n          break\n        case 'text': // text\n          value = this.rawValue(token)\n          break\n      }\n\n      if (value !== undefined) {\n        buffer += value\n      }\n    }\n\n    return buffer\n  }\n\n  /**\n   * 针对 {{#name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {string} originalTemplate template\n   * @param {renderConfig | undefined} config \n   * @returns {string | undefined}\n   */\n  private renderSection(token: token, context: Context, partials: renderPartials, originalTemplate: string, config?: renderConfig): string | undefined {\n    const self = this\n    let buffer = ''\n    let value = context.lookup(token[1]) // 获取当前的作用域值\n\n    /**\n     * 当 value 为函数时，该方法充当 value 的渲染器\n     * @param {string} template \n     * @returns {string}\n     */\n    function subRender(template: string): string {\n      return self.render(template, context, partials, config)\n    }\n\n    if (!value) return // 当值为 falsy 类型时，将不会渲染任何内容\n\n    if (isArray(value)) { // 当 value 是一个数组时，那么会遍历渲染子模板\n      for (let j = 0, valueLength = value.length; j < valueLength; ++j) {\n        // 把子 token 和当前项作用域交给 renderTokens 进行渲染\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config)\n      }\n    } else if (['object', 'string', 'number'].includes(typeof value)) { // 当 value 是对象、字符串、数字类型时，把 value 当作作用域渲染子 token\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config)\n    } else if (isFunction(value)) { // 当 value 是方法时，会根据该方法渲染模板\n      if (typeof originalTemplate !== 'string') {\n        throw new Error('Cannot use higher-order sections without the original template')\n      }\n\n      // 调用 value 获取渲染结果，第一个参数为模板中此段渲染部分的字符串，第二个参数是渲染器\n      value = value.call(\n        context.view, originalTemplate.slice(token[3], token[5]), subRender\n      ) as (t: typeof originalTemplate, r: typeof subRender) => any\n\n      if (value != null) {\n        buffer += value\n      }\n    } else { // 当 value 为 true，那么渲染子 token\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate, config)\n    }\n    return buffer\n  }\n\n  /**\n   * 针对 {{^name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {string} originalTemplate template \n   * @param {renderConfig | undefined} config \n   * @returns {string | undefined}\n   */\n  renderInverted(token: token, context: Context, partials: renderPartials, originalTemplate: string, config?: renderConfig): string | undefined {\n    const value = context.lookup(token[1]) // 获取当前的作用域值\n\n    if (!value || (isArray(value) && value.length === 0)) { // 如果 value 是 falsy 或空数组时才会渲染子 token\n      return this.renderTokens(token[4], context, partials, originalTemplate, config)\n    }\n  }\n\n  /**\n   * 处理原模板中子模板前的空白字符。\n   * \n   *  比如原模板 template = ' {{>childTemplate}}'，子模板 childTemplate = 'I\\nLove\\nU'，\n   * 那么处理后得到的结果如下：\n   * \n   * ' I\\n Love\\n U'\n   * \n   *  还有一种情况是原模板前面有非空白字符，比如 template = ' Hi,{{>childTemplate}}'，\n   * 那么处理后得到的结果如下：\n   * \n   * ' Hi,I\\n    Love\\n    U'\n   * \n   * @param {string} partial 子模板\n   * @param {string} indentation 空白字符，包含 、\\t、\\n\n   * @param {boolean} lineHasNonSpace 原模板当前行是否有非空格\n   * @returns {string}\n   */\n  indentPartial(partial: string, indentation: string, lineHasNonSpace: boolean): string {\n    const filteredIndentation = indentation.replace(/[^ \\t]/g, '') // 把换行符去掉，只保留缩进和空格\n    const partialByNl = partial.split('\\n') // 子模板以行分组处理\n\n    for (let i = 0; i < partialByNl.length; i++) {\n      // 如果当前行有非空格，那么第一行不用处理，否则统一在每行都加上 indentation\n      if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n        partialByNl[i] = filteredIndentation + partialByNl[i]\n      }\n    }\n\n    return partialByNl.join('\\n')\n  }\n\n  /**\n   * 针对 {{>name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {renderConfig | undefined} config \n   * @returns {string | undefined}\n   */\n  renderPartial(token: token, context: Context, partials: renderPartials, config?: renderConfig): string | undefined {\n    if (!partials) return // 如果子模板对象或方法为空，则不渲染任何内容\n    const tags = this.getConfigTags(config) // 获取标签类型\n\n    // 获取子模板，当 partials 为方法时，则调用方法，否则从对象中获取\n    const value = isFunction(partials) ?\n      (partials as (name: string) => string)(token[1]) :\n      (partials as { [key: string]: any })[token[1]]\n    if (value != null) {\n      const lineHasNonSpace: boolean = token[6] // 原模板当前行是否有非空格\n      const tagIndex: number = token[5] // 原模板当前行的标签数\n      const indentation: string = token[4] // 当前 token 在原模板当前行中收集到的缩进\n      let indentedValue = value as string // 处理缩进后得到的子模板\n      if (tagIndex === 0 && indentation) { // 只有在原模板当前行没有标签，才会去处理缩进\n        indentedValue = this.indentPartial(value, indentation, lineHasNonSpace)\n      }\n      const tokens = this.parse(indentedValue, tags)\n      return this.renderTokens(tokens, context, partials, indentedValue, config)\n    }\n  }\n\n  /**\n   * 针对 {{&name}} 或 {{{name}}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @returns {any | undefined}\n   */\n  private unescapedValue(token: token, context: Context): any | undefined {\n    const value = context.lookup(token[1]) // 获取当前的作用域值\n    if (value != null) {\n      return value\n    }\n  }\n\n  /**\n   * 针对 {{name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderConfig | undefined} config \n   * @returns {any | string | undefined}\n   */\n  private escapedValue(token: token, context: Context, config?: renderConfig): any | string | undefined {\n    const escape = this.getConfigEscape(config) || mustache.escape // 获取文本转义方法\n    const value = context.lookup(token[1]) // 获取当前的作用域值\n    if (value != null) {\n      // 如果 value 是数字类型并且转义方法是默认的转义方法，则把 value 转为字符串返回，否则调用自定义的转义方法返回\n      return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape!(value)\n    }\n  }\n\n  /**\n   * 针对 text 的处理\n   * @param {token} token \n   * @returns {string}\n   */\n  private rawValue(token: token): string {\n    return token[1]\n  }\n\n  /**\n   * 获取自定义标签\n   * @param {renderConfig | tags | undefined} config \n   * @returns {tags | undefined}\n   */\n  private getConfigTags(config: renderConfig | tags | undefined): tags | undefined {\n    if (isArray(config)) { // 当 config 是数组时，将当作标签直接返回\n      return config\n    }\n    else if (config && typeof config === 'object') { // 当 config 时对象时，返回 config.tags\n      return config.tags\n    }\n    else {\n      return undefined\n    }\n  }\n\n  /**\n   * 获取自定义转义器\n   * @param {renderConfig | undefined} config \n   * @returns {renderConfig.escape | undefined}\n   */\n  private getConfigEscape(config?: renderConfig): renderConfig['escape'] | undefined {\n    // 只有 config 是一个对象时，才会去获取 config.escape\n    if (config && typeof config === 'object' && !isArray(config)) {\n      return config.escape\n    }\n    else {\n      return undefined\n    }\n  }\n}\n","/**\n * mustache 对象\n */\nimport { isArray } from './utils'\nimport Scanner from './Scanner'\nimport Context from './Context'\nimport Writer from './Writer'\n\n/**\n * 标签的类型\n */\nexport type tags = [string, string]\n/**\n * 子模板对象或方法，render 的第三个参数\n */\nexport type renderPartials = { [key: string]: any } | ((name: string) => string) | undefined\n/**\n * 配置项，render 的第四个参数\n */\nexport type renderConfig = {\n  escape?: (value: string) => any,\n  tags?: tags,\n}\n/**\n * token\n */\nexport type token = any[]\n\n/**\n * 与 typeof 作用一致，但是修复了 array 为 object 的错误\n * @param {any} obj \n * @returns {'array' | typeof obj}\n */\nfunction typeStr(obj: any): 'array' | typeof obj {\n  return isArray(obj) ? 'array' : typeof obj\n}\n\ntype entity = '&' | '<' | '>' | '\"' | \"'\" | '/' | '`' | '='\nconst entityMap = { // 符号转义表\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;',\n}\n/**\n * 转义 html 文本中的符号，该方法会根据上面的 entityMap 替换\n * @param {string} string \n * @returns {string}\n */\nfunction escapeHtml(string: string): string {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s: entity) {\n    return entityMap[s]\n  })\n}\n\nconst defaultWriter = new Writer()\n\nexport const mustache = {\n  name: 'mustache.js',\n  version: '?.?.?',\n  tags: ['{{', '}}'] as [string, string], // 默认标签\n  clearCache() {\n    return defaultWriter.clearCache()\n  },\n  escape: escapeHtml,\n  parse(template: string, tags?: tags) {\n    return defaultWriter.parse(template, tags)\n  },\n  render(template: any, view: any, partials?: renderPartials, config?: renderConfig) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n        'but \"' + typeStr(template) + '\" was given as the first ' +\n        'argument for mustache#render(template, view, partials)')\n    }\n\n    return defaultWriter.render(template, view, partials, config)\n  },\n  Scanner: Scanner,\n  Context: Context,\n  Writer: Writer,\n  set templateCache(cache) {\n    defaultWriter.templateCache = cache\n  },\n  get templateCache() {\n    return defaultWriter.templateCache\n  },\n}\n","/**\n * @file mustache 源码重写 ES6 + module + 注释版\n * @see http://github.com/18023785187/my_mustache\n */\nexport { mustache } from './mustache'\n"],"names":[],"sourceRoot":""}