{"version":3,"file":"mustache.min.js","mappings":"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","sources":["webpack://mustache/webpack/universalModuleDefinition","webpack://mustache/webpack/bootstrap","webpack://mustache/webpack/runtime/define property getters","webpack://mustache/webpack/runtime/hasOwnProperty shorthand","webpack://mustache/webpack/runtime/make namespace object","webpack://mustache/./src/utils.ts","webpack://mustache/./src/Scanner.ts","webpack://mustache/./src/Context.ts","webpack://mustache/./src/parseTemplate.ts","webpack://mustache/./src/Writer.ts","webpack://mustache/./src/mustache.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mustache\"] = factory();\n\telse\n\t\troot[\"mustache\"] = factory();\n})(self, () => {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @description 以下都是为正文准备的工具方法，可以先浏览一遍对所有方法有一个印象\n */\nconst objectToString = Object.prototype.toString\nexport const isArray = Array.isArray || function isArrayPolyfill(object: any): boolean {\n  return objectToString.call(object) === '[object Array]'\n}\n\nexport function isFunction(object: any): boolean {\n  return typeof object === 'function'\n}\n\n/**\n * 检查 obj 是否为对象且 propName 是否为 obj 的属性（继承或原型链上的属性也符合）\n * @param {any} obj \n * @param {symbol | string | number} propName \n * @returns {boolean}\n */\nexport function hasProperty(obj: any, propName: symbol | string | number): boolean {\n  return obj != null && typeof obj === 'object' && (propName in obj)\n}\n\n/**\n * 判断 primitive 是否不为 null 且不为 object 且有 hasProperty 并且 propName 是 primitive 的属性\n * \n * 例如 string 类型将符合要求\n * \n * @param {any} primitive \n * @param {string} propName \n * @returns {boolean}\n */\nexport function primitiveHasOwnProperty(primitive: any, propName: string): boolean {\n  return (\n    primitive != null\n    && typeof primitive !== 'object'\n    && primitive.hasProperty\n    && primitive.hasProperty(propName)\n  )\n}\n","/**\n * 扫描器，传入字符串模板 string，通过标记 tag 收集相关 string 片段。\n * \n * scanUntil 可以收集 tag 前的字符\n * scanner 可以标识当前 tag 是否位于 string 开头\n * eos 判断 string 是否已扫描完成\n * \n * 例子：\n *  入参字符串模板为 '你好，{{name}}！'\n * \n *  scanner.scanUntil('{{') -> '你好，'\n *  scanner.eos()           -> false\n *  scanner.scan('{{')      -> '{{'\n *  scanner.eos()           -> false\n *  scanner.scanUntil('}}') -> 'name'\n *  scanner.eos()           -> false\n *  scanner.scan('}}')      -> '}}'\n *  scanner.eos()           -> false\n *  scanner.scanUntil('{{') -> '！'\n *  scanner.eos()           -> true\n */\nexport default class Scanner {\n  private string: string // 入参字符串模板\n  private tail: string // 每次扫描剩下的字符串，扫描器会从前往后扫描\n  public pos: number // 对于入参字符串模板的当前扫描到的位置\n  constructor(string: string) {\n    this.string = string\n    this.tail = string\n    this.pos = 0\n  }\n  /**\n   * 判断字符串是否已扫描完成\n   * @returns {boolean}\n   */\n  public eos(): boolean {\n    return this.tail === ''\n  }\n  /**\n   * 扫描 tag，如果 tag 在 tail 开头位置那么把 tag 匹配的字符截取并返回，否则返回空字符。\n   * \n   * @param {RegExp | string} re tag 的正则表达式或字符串\n   * @returns {string}\n   */\n  public scan(re: RegExp | string): string {\n    const match = this.tail.match(re)\n\n    if (!match || match.index !== 0) { // 如果没有匹配到或匹配到的 tag 字符串不在 tail 开头，那么返回空字符\n      return ''\n    }\n\n    const string = match[0]\n\n    this.tail = this.tail.substring(string.length)\n    this.pos += string.length\n\n    return string\n  }\n  /**\n   * 扫描 tag，跳过匹配字符串之前的字符串，并返回跳过的字符串。\n   * \n   * 三种情况：\n   *  1、如果没有匹配字符串，则返回整个 tail。\n   *  2、如果匹配字符串在 tail 的头部，说明没有可跳过的字符串，返回空字符。\n   *  3、如果匹配字符串在 tail 的中间，那么返回匹配字符串之前的字符串。\n   * \n   * 例子：\n   *  假设 tag 是 {{，\n   *    对于第一种情况，有 'hello' -> 'hello'\n   *    对于第二种情况，有 '{{hello}}' -> ''\n   *    对于第三种情况，有 'hello，{{hi}}' -> 'hello，'\n   * \n   * @param {RegExp | string} re tag 的正则表达式或字符串\n   * @returns {string}\n   */\n  public scanUntil(re: RegExp | string): string {\n    const index = this.tail.search(re)\n    let match: string\n\n    switch (index) {\n      case -1: // 第一种情况\n        match = this.tail\n        this.tail = ''\n        break\n      case 0: // 第二种情况\n        match = ''\n        break\n      default: // 第三种情况\n        match = this.tail.substring(0, index)\n        this.tail = this.tail.substring(index)\n    }\n\n    this.pos += match.length // 同时扫描指针要后移\n\n    return match\n  }\n}\n","import { isFunction, hasProperty, primitiveHasOwnProperty } from './utils'\n\n/**\n * 存储值，可以根据对应规则的标识取出特定值。\n * \n * 比如：初始化时存储的 view 是 'Tom'，那么可以调用 context.lookup('.') 取出 'Tom'，具体规则请看 lookup 方法\n */\nexport default class Context {\n  public view: any\n  public cache: { '.': Context['view'], [key: string]: any }\n  public parent?: Context\n  /**\n   * \n   * @param {any} view // 渲染值，比如 view = { name: 'Tom' }，那么调用 lookup('name') 会返回 'Tom'\n   * @param {Context} parentContext \n   */\n  constructor(view: any, parentContext?: Context) {\n    this.view = view\n    /**\n     *  缓存每次拿到的结果, 初始值为 '.'，应用场景是 {{.}}，\n     * 在每次 lookup(name) 时都会把得出的结果添加到 cache 中，下一次直接获取缓存值。比如：\n     * \n     * this.view = { a: { b: { c: 'Tom' } } }\n     * this.lookup('a') // cache: { '.': { a: { b: { c: 'Tom' } } }, 'a': { b: { c: 'Tom' } } }\n     * this.lookup('a.b') // cache: { '.': { a: { b: { c: 'Tom' } } }, 'a': { b: { c: 'Tom' } }, 'a.b': { c: 'Tom' } }\n     * this.lookup('a.b.c') // cache: { '.': { a: { b: { c: 'Tom' } } }, 'a': { b: { c: 'Tom' } }, 'a.b': { c: 'Tom' }, 'a.b.c': 'Tom' }\n     */\n    this.cache = { '.': this.view }\n    this.parent = parentContext\n  }\n\n  /**\n   * 创建一个 Context 实例，并把自身作为该实例的父 Context\n   * \n   * @param {any} view 渲染值\n   * @returns {Context}\n   */\n  public push(view: any): Context {\n    return new Context(view, this)\n  }\n\n  /**\n   * 给定 name，查找 Context 实例是否有对应的值。\n   *  \n   * 查找规则：通过存储的 view 或 context 查找。\n   * \n   * 比如 view = { a: { b: c: 'Tom' } }, name = 'a.b.c' ，那么可以找到结果，结果为 'Tom'。\n   * 比如 view = { a: 'Tom' }, name = 'b' ，那么 view 中找不到对应结果，如果有父 context，将会找父 context 中的 view，直到找到或不再存在父 context 为止。\n   * \n   * @param {string} name 属性链，比如是 '.'、'a'、'a.b.c' 等\n   * @returns {any}\n   */\n  public lookup(name: string): any {\n    const cache = this.cache // 获取缓存结果对象\n\n    let value: any // 结果值\n    if (cache.hasOwnProperty(name)) { // 如果在之前缓存有该值，那么直接取到\n      value = cache[name]\n    } else {\n      let context: this | Context['parent'] = this // 当前作用域\n      let intermediateValue: any // 过渡值，类似于数组两个数交换时定义的一个 temp\n      let names: string[] // 分割后的 name 数组\n      let index: number // 指向 names 的索引\n      let lookupHit = false // 是否找到目标值\n\n      while (context) {\n        if (name.indexOf('.') > 0) {\n          intermediateValue = context.view // 初始化 intermediateValue\n          names = name.split('.') // 如果 name 是 'a.b.c'，则拆成 ['a', 'b', 'c']\n          index = 0\n\n          while (intermediateValue != null && index < names.length) {\n            if (index === names.length - 1) {\n              lookupHit = (\n                hasProperty(intermediateValue, names[index])\n                /**\n                 * 这种情形在 intermediateValue 是个字符串，names[index] 是索引时适用\n                 * \n                 * intermediateValue = 'hello'\n                 * name = a.b.c.0, names[index] = '0'\n                 * \n                 * primitiveHasOwnProperty(intermediateValue, names[index]) // true\n                 */\n                || primitiveHasOwnProperty(intermediateValue, names[index])\n              )\n            }\n\n            /**\n             * 这个操作相当于链式获取某个值，比如：\n             * \n             *  intermediateValue = { a: { b: { c: 'Tom' } } }, names = ['a', 'b', 'c']\n             * \n             * 那么每次循环的情景是：\n             *  intermediateValue = intermediateValue['a'] // { b: { c: 'Tom' } }\n             *  intermediateValue = intermediateValue['b'] // { c: 'Tom' }\n             *  intermediateValue = intermediateValue['c'] // 'Tom'\n             */\n            intermediateValue = intermediateValue[names[index++]]\n          }\n        } else { // 如果 name 中没有 .\n          intermediateValue = context.view[name]\n\n          lookupHit = hasProperty(context.view, name)\n        }\n\n        if (lookupHit) { // 如果找到了目标值，那么结束循环\n          value = intermediateValue\n          break\n        }\n\n        context = context.parent // 如果没有找到目标值，那么继续往上找父 context，直到找到或 context 为空\n      }\n\n      cache[name] = value // 向 cache 添加结果，下次遇到相同值直接取出\n    }\n\n    if (isFunction(value)) { // 如果 value 是一个函数，那么调用该函数把返回值赋值给 value\n      value = value.call(this.view)\n    }\n\n    return value\n  }\n}\n","import { mustache, tags, token } from './mustache'\nimport { isArray } from './utils'\nimport Scanner from './Scanner'\n\n/**\n * 在所有 - [ ] { } ( ) * + ? . , \\ ^ $ # 所有空格 前添加 \\\n * 如 '-[]' -> '\\-\\[\\]'\n * @param {string} string \n * @returns {string}\n */\nfunction escapeRegExp(string: string): string {\n  return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, '\\\\$&')\n}\n\nconst regExpTest = RegExp.prototype.test\nfunction testRegExp(re: RegExp, string: string): boolean {\n  return regExpTest.call(re, string)\n}\n\nconst nonSpaceRe = /\\S/ // 匹配非空字符\nfunction isWhitespace(string: string): boolean { // 检查一个值是否为空白字符串\n  return !testRegExp(nonSpaceRe, string)\n}\n\nconst whiteRe = /\\s*/ // 匹配空白\nconst spaceRe = /\\s+/ // 匹配至少一个空格\nconst equalsRe = /\\s*=/ // 匹配 =\nconst curlyRe = /\\s*\\}/ // 匹配 }\nconst tagRe = /#|\\^|\\/|>|\\{|&|=|!/ // 匹配 #、^、/、>、{、&、=、!\n\n/**\n * 扫描 template，根据 tags 及其规则生成 tokens\n * \n *  tokens 是一个多维数组，其作为某段 template 片段的描述，类似于 AST 抽象语法树，\n * 将文字解析成 tokens 后可以根据里面 token 更好更有规律地转义 template。\n * \n * 例子：\n *  const template = '你好，{{name}}！'\n *  const tags = ['{{', '}}']\n * \n *  parseTemplate(template, tags) // [[ 'text', '你好，', 0, 3 ], [ 'name', 'name', 3, 11 ], [ 'text', '！', 11, 12 ]]\n * \n *  上述 tokens 中的 token 是最基础的形态，类型为 [type, text, startIdx, endIdx]\n * \n *  其中：\n *    type 为该 token 的处理类型，后续可以根据 type 来对该 token 进行处理;\n *    text 为该 token 的文本信息，该文本就是在 template 提取的文本;\n *    startIdx 和 endIdx 为该 token 对于 template 的起始和结束的位置索引;\n * \n *    实际上根据 type 的不同生成的 token 类型也会有所不同，比如某类 token 还会存储儿子 token，\n *  这就是说为什么 tokens 是一个多维数组的原因。具体的 token 生成规则和处理方法，请继续往下看。\n * \n * 注：下面所有例子和描述的 tags 以默认值 ['{{', '}}'] 为例\n * \n * @param {string} template 字符串模版\n * @param {tags} tags 标记\n * @returns {token[]} tokens\n */\nexport default function parseTemplate(template: string, tags?: tags): token[] {\n  if (!template) {\n    return []\n  }\n  let lineHasNonSpace = false // 当前行是否有非空格\n  const sections = [] // 存储 {{#names}}、{{^names}} 标记，用于判断这些标记是否有匹配 {{/names}}\n  const tokens: token[] = [] // token 数组\n  let spaces: number[] = [] // 存储在当前行中每个空格的 token 索引，当遇到 {{#names}} 时且当前项全是空格时，会把 tokens 中对应 spaces 索引的 token 全部删除\n  let hasTag = false // 当前行是否有标签 {{}}\n  let nonSpace = false // 是否有非空格\n  let indentation = '' // 当前行收集到的缩进，又称空白字符串\n  let tagIndex = 0 // 每一行文本所遇到的 {{}} 数量\n\n  /**\n   * 当遇到 {{#names}} 且当前行全部为空格时，会把所有空格移除。\n   * \n   * 例如 : \n   *  template: '    {{#names}}    \\n{{name}}{{/names}}'\n   *  view: { names: { name: 'Tom' } }\n   * \n   *  output: 'Tom'\n   * \n   * {{#names}} 前后的空格已被移除，但当 {{#names}} 所在的当前行如果有非空格字符，这个规则将不适用。\n   */\n  function stripSpace(): void {\n    if (hasTag && !nonSpace) { // 如果检测到有标签且全是空格，这里的标签只能是 {{#names}}\n      while (spaces.length) // 删除 tokens 中所有空格 token\n        delete tokens[spaces.pop() as number]\n    } else {\n      spaces = [] // 重置\n    }\n\n    hasTag = false // 重置\n    nonSpace = false // 重置\n  }\n\n  let openingTagRe: RegExp // 开口标签正则\n  let closingTagRe: RegExp // 闭口标签正则\n  let closingCurlyRe: RegExp // } + closingTagRe 正则，比如闭口标签为 }}，那么该正则为 }}}\n  /**\n   * 处理 tags，根据 tags 生成对应的正则表达式，tags 必须为数组或字符串，例如 ['{{', '}}'] 或 '{{ }}'\n   * \n   * 为什么会有字符串？因为在遇到 {{=<% %>=}} 的时候会把 '<% %>' 作为参数传入，这时就需要将其解析为标签\n   * \n   * @param {string | tags} tagsToCompile \n   */\n  function compileTags(tagsToCompile: string | tags): void {\n    if (typeof tagsToCompile === 'string') {\n      tagsToCompile = tagsToCompile.split(spaceRe, 2) as tags // 生成至少一个空格作为分隔符，长度为 2 的数组，例如： '{{  }}' -> ['{{', '}}']\n    }\n\n    if (!isArray(tagsToCompile) && (tagsToCompile as string[]).length !== 2) { // 如果 tagsToCompile 不是数组或数组长度不等于 2，说明不符合条件，抛出错误\n      throw new Error('Invalid tags: ' + tagsToCompile)\n    }\n\n    openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\\\s*') // /\\{\\{\\s*/\n    closingTagRe = new RegExp('\\\\s*' + escapeRegExp(tagsToCompile[1])) // /\\s*\\}\\}/\n    closingCurlyRe = new RegExp('\\\\s*' + escapeRegExp('}' + tagsToCompile[1])) // /\\s*\\}\\}\\}/\n  }\n\n  compileTags(tags || mustache.tags) // 初始化编译一个 tags 确定标签的样式\n\n  const scanner = new Scanner(template) // 创建扫描器，下面循环将围绕扫描器收集 token\n\n  let start: number // 每次扫描一对 {{}} 即每次循环时，扫描器 scanner 的当前指针\n  let type: string // 每个标签的类型，后面会根据类型去处理 token\n  let value: string // {{ 或 }} 前的文本，比如：'hello, {{name}}' 对应的文本是 hello, 和 name\n  let chr: string // 文本中每一个字符\n  let token: token // 存储的信息标识\n  let openSection: token | undefined // 每次遇到 {{/names}} 时从 sections 弹出的开口标签\n  while (!scanner.eos()) { // 循环使扫描器扫描完成，每次循环都会扫描出一对 {{}}\n    start = scanner.pos\n\n    value = scanner.scanUntil(openingTagRe!) // 获取 {{ 前或全部文本\n\n    if (value) { // 循环将文本转换成单字符 token，方便后续处理\n      for (let i = 0, valueLength = value.length; i < valueLength; ++i) {\n        chr = value.charAt(i) // 获取当前字符\n\n        if (isWhitespace(chr)) { // 如果该字符为空白字符，记录该空白 token 的位置，同时增加缩进的长度\n          spaces.push(tokens.length)\n          indentation += chr\n        } else {\n          /**\n           * @see {Writer.indentPartial} 如果有非空白字符，记录当前行有非空格字符，缩进长度也需增加\n           */\n          nonSpace = true\n          lineHasNonSpace = true\n          indentation += ' '\n        }\n\n        tokens.push(['text', chr, start, start + 1])\n        start += 1\n\n        if (chr === '\\n') { // 如果 chr 是一个换行符，说明当前行已经遍历结束，重置新的行\n          stripSpace()\n          indentation = ''\n          tagIndex = 0\n          lineHasNonSpace = false\n        }\n      }\n    }\n\n    if (!scanner.scan(openingTagRe!)) { // 如果找不到 {{ ，返回\n      break\n    }\n\n    hasTag = true // 否则该行一定有 {{ 标签\n\n    type = scanner.scan(tagRe) || 'name' // 获取标签的类型，要么是特殊标签，要么是普通标签 {{name}}\n    scanner.scan(whiteRe) // 跳过空格\n\n    // 根据 type 收集 value\n    if (type === '=') { // type 为 =，说明需要转换标签样式，收集即将需要转换的样式\n      /**\n       * @see {compileTags}\n       */\n      value = scanner.scanUntil(equalsRe)\n      scanner.scan(equalsRe)\n      scanner.scanUntil(closingTagRe!)\n    } else if (type === '{') { // type 为 { 说明是 {{{name}}}，使得 name 中的值跳过转义，如 name = '<Tom'，那么直接输出 '<Tom'，而 {{name}} 会输出 '&lt;Tom'\n      value = scanner.scanUntil(closingCurlyRe!) // 获取 {{{name}}} 中的 name\n      scanner.scan(curlyRe) // 跳过 }\n      scanner.scanUntil(closingTagRe!) // 跳过 }}\n      type = '&' // 无论是 {{&name}} 或 {{{name}}}，其类型都是 &\n    } else {\n      value = scanner.scanUntil(closingTagRe!) // 收集 {{name}} 中的 name\n    }\n\n    if (!scanner.scan(closingTagRe!)) { // 如果没有找到 }}，那么说明标签不匹配，抛出错误\n      throw new Error('Unclosed tag at ' + scanner.pos)\n    }\n\n    if (type === '>') {\n      token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace]\n    } else {\n      token = [type, value, start, scanner.pos]\n    }\n    tagIndex++ // 当前行遇到的标签数加一\n\n    tokens.push(token)\n\n    if (type === '#' || type === '^') { // 如果遇到 {{#names}} 或 {{^names}}，\n      sections.push(token) // 把 token 推入 sections 数组。\n    } else if (type === '/') { // 如果遇到 {{/names}}，\n      openSection = sections.pop() // 把与之匹配的 {{#names}} 弹出。\n\n      if (!openSection) { // 如果没有 {{#names}}，说明闭口标签没有匹配的开口标签，抛出错误\n        throw new Error('Unopened section \"' + value + '\" at ' + start)\n      }\n\n      if (openSection[1] !== value) { // 如果两者变量不匹配，例如：{{#names}}{{/ages}}，说明不符合规则，抛出错误\n        throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + start)\n      }\n    } else if (type === 'name' || type === '{' || type === '&') { // 这种情况为普通标签\n      nonSpace = true\n    } else if (type === '=') { // 如果 type 为 = ，说明标签需要转换，例如 {{=<% %>=}} 使 {{}} 转为 <%%>\n      compileTags(value)\n    }\n  }\n\n  stripSpace()\n\n  openSection = sections.pop()\n\n  if (openSection) { // 扫描完成，所有的 {{#names}} 都应该被出栈，如果有剩余的 {{#names}} 则说明剩余的开闭标签没有成对出现\n    throw new Error('Unclosed section \"' + openSection[1] + '\" at ' + scanner.pos)\n  }\n\n  // return tokens // 未处理的 tokens\n  // return squashTokens(tokens) // 把连续的 tokens 合并\n  return nestTokens(squashTokens(tokens)) // 把散列的儿子 tokens 合并到父 token 中\n}\n\n/**\n * 把连续序号的散列 token 合并到一个 token 中。\n * \n * 例子：\n *  const tokens = [['text', 'T', 0, 1], ['text', 'o', 1, 2], ['text', 'm', 2, 3]]\n * \n *  squashTokens(tokens) // [['text', 'Tom', 0, 3]]\n * \n * @param {token[]} tokens \n * @returns {token[]}\n */\nfunction squashTokens(tokens: token[]): token[] {\n  const squashedTokens: token[] = [] // 合并完成后的 tokens\n\n  let token: token | undefined\n  let lastToken: token | undefined // 合并的 token\n  for (let i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i]\n\n    if (token) { // token 并非一定存在，在清除空格 token 的情况下当前位置将会是 empty\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') { // 如果当前 token 和合并 token 都是普通文本，那么进行合并操作\n        // 一个普通的 token: ['text', word, startIdx, endIdx]\n        lastToken[1] += token[1]\n        lastToken[3] = token[3]\n      } else {\n        squashedTokens.push(token)\n        lastToken = token\n      }\n    }\n  }\n\n  return squashedTokens\n}\n\n/**\n * 对于类型为 #、^ 的 token 都会有对应的儿子 token，该函数的作用就是把散列的儿子 token 收集起来存储到其父亲 token 中。\n * \n * 例子：\n *  const tokens = [['#', 'a', 0, 6], ['name', 'b', 6, 11], ['/', 'a', 11, 17]]\n * \n *  nestTokens(tokens) // [['#', 'a', 0, 6, ['name', 'b', 6, 11], 11]]\n * \n * @param {token[]} tokens \n * @returns {token[]}\n */\nfunction nestTokens(tokens: token[]): token[] {\n  const nestedTokens: token[] = [] // 结果 tokens\n  let collector = nestedTokens // 当前操作的 token\n  const sections: token[] = [] // 存储操作的 token 的栈，栈顶元素指向当前操作的 token 的父亲 token 或 nestedTokens\n\n  let token: token\n  let section: token\n  for (let i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n    token = tokens[i]\n\n    switch (token[0]) { // type\n      /**\n       * 如果是开口标签标记，那么他应该有儿子 token，需要对该 token 进行处理\n       * [type, key, startIdx, childrenStartIdx, children, endIdx]\n       */\n      case '#':\n      case '^':\n        collector.push(token)\n        sections.push(token)\n        collector = token[4] = [] // 为当前 token 开辟存储儿子 token 的空间，同时 collector 指向儿子 token\n        break\n      case '/': // 如果遇到结束标签标记，说明当前 collector 已处理完毕\n        section = sections.pop()!\n        section[5] = token[2]\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens\n        break\n      default:\n        collector.push(token)\n    }\n  }\n\n  return nestedTokens\n}\n","import { mustache, token, renderConfig, renderPartials, tags } from './mustache'\nimport parseTemplate from './parseTemplate'\nimport Context from './Context'\nimport { isArray, isFunction } from './utils'\n\n/**\n * Writer 整合了各类工具，集成了 mustache 的各类方法，可以针对 token 的类型处理模板，为核心类。\n * Writer 还具有缓存功能，能够将相同条件下生成的 tokens 进行缓存，在下次遇到相同条件时取出缓存值即可。\n */\nexport default class Writer {\n  public templateCache: {\n    _cache: { [key: string]: token[] },\n    set: (key: string, value: token[]) => void,\n    get: (key: string) => token[] | undefined,\n    clear: () => void,\n  }\n  constructor() {\n    // 创建缓存器，用于缓存转义后的模板 tokens\n    this.templateCache = {\n      _cache: {},\n      set: function set(key, value) {\n        this._cache[key] = value\n      },\n      get: function get(key) {\n        return this._cache[key]\n      },\n      clear: function clear() {\n        this._cache = {}\n      }\n    }\n  }\n\n  /**\n   * 清除缓存对象中的缓存值\n   */\n  public clearCache(): void {\n    if (typeof this.templateCache !== 'undefined') {\n      this.templateCache.clear()\n    }\n  }\n\n  /**\n   * 查找缓存或调用 parseTemplate 方法将 template 转为 tokens\n   * @see parseTemplate\n   * @param {string} template \n   * @param {tags} tags \n   * @returns {token[]}\n   */\n  public parse(template: string, tags?: tags): token[] {\n    const cache = this.templateCache // 获取缓存对象\n    const cacheKey = template + ':' + (tags || mustache.tags).join(':') // 创建缓存标识\n    const isCacheEnabled = typeof cache !== 'undefined' // 获取是否需要缓存标识\n    let tokens = isCacheEnabled ? cache.get(cacheKey) : undefined\n\n    if (tokens == undefined) { // 如果没有缓存或未开启获取，则调用 parseTemplate 得到 tokens\n      tokens = parseTemplate(template, tags)\n      isCacheEnabled && cache.set(cacheKey, tokens)\n    }\n    return tokens\n  }\n\n  /**\n   * 把 tokens 转换为结果视图\n   * @param {string} template 模板\n   * @param {any} view 渲染视图\n   * @param {renderPartials} partials 子模板对象或方法\n   * @param {renderConfig} config 配置项\n   * @returns {string}\n   */\n  public render(template: string, view: any, partials: renderPartials, config: renderConfig | undefined): string {\n    const tags = this.getConfigTags(config)\n    const tokens = this.parse(template, tags)\n    const context = (view instanceof Context) ? view : new Context(view, undefined)\n    return this.renderTokens(tokens, context, partials, template, config)\n  }\n\n  /**\n   * 根据 token 的标识用不同的方法处理 token\n   * @param {token[]} tokens \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {string} originalTemplate template\n   * @param {renderConfig | undefined} config \n   * @returns {string}\n   */\n  private renderTokens(tokens: token[], context: Context, partials: renderPartials, originalTemplate: string, config?: renderConfig): string {\n    let buffer = '' // 结果，由 token 和 context 根据规则生成的文本内容\n\n    let token: token\n    let symbol: string\n    let value: string | undefined\n    for (let i = 0, numTokens = tokens.length; i < numTokens; ++i) {\n      value = undefined // 重置 value\n      token = tokens[i] // 获取当前 token\n      symbol = token[0] // 获取 token 标识\n\n      switch (symbol) { // 根据标识决定使用何种方式处理 token\n        case '#': // {{#name}}\n          value = this.renderSection(token, context, partials, originalTemplate, config)\n          break\n        case '^': // {{^name}}\n          value = this.renderInverted(token, context, partials, originalTemplate, config)\n          break\n        case '>': // {{>name}}\n          value = this.renderPartial(token, context, partials, config)\n          break\n        case '&': // {{&name}} 或 {{{name}}}\n          value = this.unescapedValue(token, context)\n          break\n        case 'name': // {{name}}\n          value = this.escapedValue(token, context, config)\n          break\n        case 'text': // text\n          value = this.rawValue(token)\n          break\n      }\n\n      if (value !== undefined) {\n        buffer += value\n      }\n    }\n\n    return buffer\n  }\n\n  /**\n   * 针对 {{#name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {string} originalTemplate template\n   * @param {renderConfig | undefined} config \n   * @returns {string | undefined}\n   */\n  private renderSection(token: token, context: Context, partials: renderPartials, originalTemplate: string, config?: renderConfig): string | undefined {\n    const self = this\n    let buffer = ''\n    let value = context.lookup(token[1]) // 获取当前的作用域值\n\n    /**\n     * 当 value 为函数时，该方法充当 value 的渲染器\n     * @param {string} template \n     * @returns {string}\n     */\n    function subRender(template: string): string {\n      return self.render(template, context, partials, config)\n    }\n\n    if (!value) return // 当值为 falsy 类型时，将不会渲染任何内容\n\n    if (isArray(value)) { // 当 value 是一个数组时，那么会遍历渲染子模板\n      for (let j = 0, valueLength = value.length; j < valueLength; ++j) {\n        // 把子 token 和当前项作用域交给 renderTokens 进行渲染\n        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config)\n      }\n    } else if (['object', 'string', 'number'].includes(typeof value)) { // 当 value 是对象、字符串、数字类型时，把 value 当作作用域渲染子 token\n      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config)\n    } else if (isFunction(value)) { // 当 value 是方法时，会根据该方法渲染模板\n      if (typeof originalTemplate !== 'string') {\n        throw new Error('Cannot use higher-order sections without the original template')\n      }\n\n      // 调用 value 获取渲染结果，第一个参数为模板中此段渲染部分的字符串，第二个参数是渲染器\n      value = value.call(\n        context.view, originalTemplate.slice(token[3], token[5]), subRender\n      ) as (t: typeof originalTemplate, r: typeof subRender) => any\n\n      if (value != null) {\n        buffer += value\n      }\n    } else { // 当 value 为 true，那么渲染子 token\n      buffer += this.renderTokens(token[4], context, partials, originalTemplate, config)\n    }\n    return buffer\n  }\n\n  /**\n   * 针对 {{^name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {string} originalTemplate template \n   * @param {renderConfig | undefined} config \n   * @returns {string | undefined}\n   */\n  renderInverted(token: token, context: Context, partials: renderPartials, originalTemplate: string, config?: renderConfig): string | undefined {\n    const value = context.lookup(token[1]) // 获取当前的作用域值\n\n    if (!value || (isArray(value) && value.length === 0)) { // 如果 value 是 falsy 或空数组时才会渲染子 token\n      return this.renderTokens(token[4], context, partials, originalTemplate, config)\n    }\n  }\n\n  /**\n   * 处理原模板中子模板前的空白字符。\n   * \n   *  比如原模板 template = ' {{>childTemplate}}'，子模板 childTemplate = 'I\\nLove\\nU'，\n   * 那么处理后得到的结果如下：\n   * \n   * ' I\\n Love\\n U'\n   * \n   *  还有一种情况是原模板前面有非空白字符，比如 template = ' Hi,{{>childTemplate}}'，\n   * 那么处理后得到的结果如下：\n   * \n   * ' Hi,I\\n    Love\\n    U'\n   * \n   * @param {string} partial 子模板\n   * @param {string} indentation 空白字符，包含 、\\t、\\n\n   * @param {boolean} lineHasNonSpace 原模板当前行是否有非空格\n   * @returns {string}\n   */\n  indentPartial(partial: string, indentation: string, lineHasNonSpace: boolean): string {\n    const filteredIndentation = indentation.replace(/[^ \\t]/g, '') // 把换行符去掉，只保留缩进和空格\n    const partialByNl = partial.split('\\n') // 子模板以行分组处理\n\n    for (let i = 0; i < partialByNl.length; i++) {\n      // 如果当前行有非空格，那么第一行不用处理，否则统一在每行都加上 indentation\n      if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {\n        partialByNl[i] = filteredIndentation + partialByNl[i]\n      }\n    }\n\n    return partialByNl.join('\\n')\n  }\n\n  /**\n   * 针对 {{>name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderPartials} partials \n   * @param {renderConfig | undefined} config \n   * @returns {string | undefined}\n   */\n  renderPartial(token: token, context: Context, partials: renderPartials, config?: renderConfig): string | undefined {\n    if (!partials) return // 如果子模板对象或方法为空，则不渲染任何内容\n    const tags = this.getConfigTags(config) // 获取标签类型\n\n    // 获取子模板，当 partials 为方法时，则调用方法，否则从对象中获取\n    const value = isFunction(partials) ?\n      (partials as (name: string) => string)(token[1]) :\n      (partials as { [key: string]: any })[token[1]]\n    if (value != null) {\n      const lineHasNonSpace: boolean = token[6] // 原模板当前行是否有非空格\n      const tagIndex: number = token[5] // 原模板当前行的标签数\n      const indentation: string = token[4] // 当前 token 在原模板当前行中收集到的缩进\n      let indentedValue = value as string // 处理缩进后得到的子模板\n      if (tagIndex === 0 && indentation) { // 只有在原模板当前行没有标签，才会去处理缩进\n        indentedValue = this.indentPartial(value, indentation, lineHasNonSpace)\n      }\n      const tokens = this.parse(indentedValue, tags)\n      return this.renderTokens(tokens, context, partials, indentedValue, config)\n    }\n  }\n\n  /**\n   * 针对 {{&name}} 或 {{{name}}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @returns {any | undefined}\n   */\n  private unescapedValue(token: token, context: Context): any | undefined {\n    const value = context.lookup(token[1]) // 获取当前的作用域值\n    if (value != null) {\n      return value\n    }\n  }\n\n  /**\n   * 针对 {{name}} 的处理\n   * @param {token} token \n   * @param {Context} context \n   * @param {renderConfig | undefined} config \n   * @returns {any | string | undefined}\n   */\n  private escapedValue(token: token, context: Context, config?: renderConfig): any | string | undefined {\n    const escape = this.getConfigEscape(config) || mustache.escape // 获取文本转义方法\n    const value = context.lookup(token[1]) // 获取当前的作用域值\n    if (value != null) {\n      // 如果 value 是数字类型并且转义方法是默认的转义方法，则把 value 转为字符串返回，否则调用自定义的转义方法返回\n      return (typeof value === 'number' && escape === mustache.escape) ? String(value) : escape!(value)\n    }\n  }\n\n  /**\n   * 针对 text 的处理\n   * @param {token} token \n   * @returns {string}\n   */\n  private rawValue(token: token): string {\n    return token[1]\n  }\n\n  /**\n   * 获取自定义标签\n   * @param {renderConfig | tags | undefined} config \n   * @returns {tags | undefined}\n   */\n  private getConfigTags(config: renderConfig | tags | undefined): tags | undefined {\n    if (isArray(config)) { // 当 config 是数组时，将当作标签直接返回\n      return config\n    }\n    else if (config && typeof config === 'object') { // 当 config 时对象时，返回 config.tags\n      return config.tags\n    }\n    else {\n      return undefined\n    }\n  }\n\n  /**\n   * 获取自定义转义器\n   * @param {renderConfig | undefined} config \n   * @returns {renderConfig.escape | undefined}\n   */\n  private getConfigEscape(config?: renderConfig): renderConfig['escape'] | undefined {\n    // 只有 config 是一个对象时，才会去获取 config.escape\n    if (config && typeof config === 'object' && !isArray(config)) {\n      return config.escape\n    }\n    else {\n      return undefined\n    }\n  }\n}\n","/**\n * mustache 对象\n */\nimport { isArray } from './utils'\nimport Scanner from './Scanner'\nimport Context from './Context'\nimport Writer from './Writer'\n\n/**\n * 标签的类型\n */\nexport type tags = [string, string]\n/**\n * 子模板对象或方法，render 的第三个参数\n */\nexport type renderPartials = { [key: string]: any } | ((name: string) => string) | undefined\n/**\n * 配置项，render 的第四个参数\n */\nexport type renderConfig = {\n  escape?: (value: string) => any,\n  tags?: tags,\n}\n/**\n * token\n */\nexport type token = any[]\n\n/**\n * 与 typeof 作用一致，但是修复了 array 为 object 的错误\n * @param {any} obj \n * @returns {'array' | typeof obj}\n */\nfunction typeStr(obj: any): 'array' | typeof obj {\n  return isArray(obj) ? 'array' : typeof obj\n}\n\ntype entity = '&' | '<' | '>' | '\"' | \"'\" | '/' | '`' | '='\nconst entityMap = { // 符号转义表\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n  '/': '&#x2F;',\n  '`': '&#x60;',\n  '=': '&#x3D;',\n}\n/**\n * 转义 html 文本中的符号，该方法会根据上面的 entityMap 替换\n * @param {string} string \n * @returns {string}\n */\nfunction escapeHtml(string: string): string {\n  return String(string).replace(/[&<>\"'`=\\/]/g, function fromEntityMap(s: entity) {\n    return entityMap[s]\n  })\n}\n\nconst defaultWriter = new Writer()\n\nexport const mustache = {\n  name: 'mustache.js',\n  version: '?.?.?',\n  tags: ['{{', '}}'] as [string, string], // 默认标签\n  clearCache() {\n    return defaultWriter.clearCache()\n  },\n  escape: escapeHtml,\n  parse(template: string, tags?: tags) {\n    return defaultWriter.parse(template, tags)\n  },\n  render(template: any, view: any, partials?: renderPartials, config?: renderConfig) {\n    if (typeof template !== 'string') {\n      throw new TypeError('Invalid template! Template should be a \"string\" ' +\n        'but \"' + typeStr(template) + '\" was given as the first ' +\n        'argument for mustache#render(template, view, partials)')\n    }\n\n    return defaultWriter.render(template, view, partials, config)\n  },\n  Scanner: Scanner,\n  Context: Context,\n  Writer: Writer,\n  set templateCache(cache) {\n    defaultWriter.templateCache = cache\n  },\n  get templateCache() {\n    return defaultWriter.templateCache\n  },\n}\n"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","objectToString","toString","isArray","Array","object","isFunction","hasProperty","propName","Scanner","constructor","string","this","tail","pos","eos","scan","re","match","index","substring","length","scanUntil","search","Context","view","parentContext","cache","parent","push","lookup","name","intermediateValue","names","context","lookupHit","indexOf","split","primitive","escapeRegExp","replace","regExpTest","RegExp","test","nonSpaceRe","isWhitespace","testRegExp","whiteRe","spaceRe","equalsRe","curlyRe","tagRe","Writer","templateCache","_cache","set","clear","clearCache","parse","template","tags","cacheKey","mustache","join","isCacheEnabled","tokens","undefined","lineHasNonSpace","sections","openingTagRe","closingTagRe","closingCurlyRe","spaces","hasTag","nonSpace","indentation","tagIndex","stripSpace","pop","compileTags","tagsToCompile","Error","scanner","start","type","chr","token","openSection","i","valueLength","charAt","nestedTokens","collector","section","numTokens","nestTokens","squashedTokens","lastToken","squashTokens","parseTemplate","render","partials","config","getConfigTags","renderTokens","originalTemplate","symbol","buffer","renderSection","renderInverted","renderPartial","unescapedValue","escapedValue","rawValue","j","includes","slice","indentPartial","partial","filteredIndentation","partialByNl","indentedValue","escape","getConfigEscape","String","entityMap","defaultWriter","version","s","TypeError"],"sourceRoot":""}